<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Assignment 5: Improve performance of BVH construction by fishirenee</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Assignment 5: Improve performance of BVH construction</h1>
      <h2 class="project-tagline">CMU 15-462/662 Assignment 5: Improve performance of BVH construction</h2>
      <a href="https://github.com/fishirenee/15662_asst5" class="btn">View on GitHub</a>
      <a href="https://github.com/fishirenee/15662_asst5/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/fishirenee/15662_asst5/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="final-project-improve-performance-of-bvh-construction" class="anchor" href="#final-project-improve-performance-of-bvh-construction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Final Project: Improve performance of BVH construction</h2>

<p>My topic for the final project is option F: Advanced Monte Carlo Rendering. And the track I implemented is improving the performance of the BVH path tracing. I followed the article <em>“Fast Parallel Construction of High-Quality Bounding Volume Hierarchies”</em>. However, I tried to realize a Parallel construction system but since I'm new to the area I didn't make it. So I didn’t realize the full function out.</p>

<p>I will introduce the functions I have for now. The performance improving functions are based on the assignment 3. And currently all the works are done in the bvh.cpp.</p>

<p>Since we already have a basic BVH structure ready from assignment 3. I started with it and tried to form the treelet structure according to the article. The overall idea is: For each node, set the number of leaf node to 7 and the internal node number to 5. While traveling through the original BVH tree. Rearrange the relationship of the "internal node" according to the new SAH cost of every possible arrangement. And let the smallest cost one to be the final internal node arrangement, keeping the relationship of the internal node and the corresponding leaf nodes.</p>

<p>I have the following functions to realize the thought above:</p>

<ul>
<li>getArea() 

<ul>
<li>Input: the maximum and minimum value of the vertex.</li>
<li>Output: the surface area.</li>
</ul>
</li>
</ul>

<blockquote>
<p>get the surface area of the bounding box according to the diagonal line’s vertex.</p>
</blockquote>

<pre><code>double getArea(double min_x, double max_x, double min_y, double max_y, double min_z, double max_z) {
  double dx = max_x - min_x;
  double dy = max_y - min_y;
  double dz = max_z - min_z;
  return 2 * (dx * dy + dx * dz + dy * dz);
}
</code></pre>

<ul>
<li>getTotalArea()

<ul>
<li>Input: the leaves of the node and the number of the leaves</li>
<li>Output: the total bounding box area of the leaves</li>
</ul>
</li>
</ul>

<blockquote>
<p>get the total area of the bounding box of the leaves</p>
</blockquote>

<pre><code>double getTotalArea(int n, std::vector&lt;BVHNode *&gt; leaves) {
  double lmin_x, lmin_y, lmin_z, lmax_x, lmax_y, lmax_z;
  double min_x = INF_D;
  double max_x = -INF_D;
  double min_y = INF_D;
  double max_y = -INF_D;
  double min_z = INF_D;
  double max_z = -INF_D; 
  for (int i = 0; i &lt; n; i++) {
    // if ((s &gt;&gt; i) &amp; 1 == 1) {
    lmin_x = leaves[i]-&gt;bb.min.x;
    lmin_y = leaves[i]-&gt;bb.min.y;
    lmin_z = leaves[i]-&gt;bb.min.z;
    lmax_x = leaves[i]-&gt;bb.max.x;
    lmax_y = leaves[i]-&gt;bb.max.y;
    lmax_z = leaves[i]-&gt;bb.max.z;
    if (lmin_x &lt; min_x) min_x = lmin_x;
    if (lmin_y &lt; min_y) min_y = lmin_y;
    if (lmin_z &lt; min_z) min_z = lmin_z;
    if (lmax_x &gt; max_x) max_x = lmax_x;
    if (lmax_y &gt; max_y) max_y = lmax_y;
    if (lmax_z &gt; max_z) max_z = lmax_z;
    // }
  } 
  return getArea(min_x, max_x, min_y, max_y, min_z, max_z);
}
</code></pre>

<ul>
<li>mergeBox()

<ul>
<li>Input: bounding box1, bounding box2, bounding box3</li>
<li>Output: void</li>
</ul>
</li>
</ul>

<blockquote>
<p>reset the bounding box3’s attributes using the smallest and largest attributes from bounding box1 and bounding box2.</p>
</blockquote>

<pre><code>void mergeBox(BBox&amp; b1, BBox&amp; b2, BBox* b3) {
   b3-&gt;min.x = std::min(b1.min.x, b2.min.x);
   b3-&gt;max.x = std::max(b1.max.x, b2.max.x);
   b3-&gt;min.y = std::min(b1.min.y, b2.min.y);
   b3-&gt;max.y = std::max(b1.max.y, b2.max.y);
   b3-&gt;min.z = std::min(b1.min.z, b2.min.z);
   b3-&gt;max.z = std::max(b1.max.z, b2.max.z);
   return;
}
</code></pre>

<ul>
<li>optimizeTreelet()

<ul>
<li>Input: the number of the leaves</li>
<li>Output: void</li>
</ul>
</li>
</ul>

<blockquote>
<p>rearrange the leaves' partition to get the smallest cost arrangement</p>
</blockquote>

<pre><code>void optimizeTreelet(int n, std::vector&lt;BVHNode *&gt; leaves) {
  int num_subsets = pow(2, n) - 1;

  double area[128];
  double c_opt[128];

  // Calculate surface area for each subset
  for (int s = 1; s &lt;= num_subsets; s++) {
    area[s] = getTotalArea(n, leaves, s);
  }

  // Initialize costs of individual leaves
  for (int i = 0; i &lt;= (n-1); i++) {
    c_opt[pow(2, i)] = leaves[i]-&gt;cost;
  }

  // Optimize every arrangement of leaves
  for (unsigned k = 2; k &lt;= n; k++) {
    for (unsigned char s = 1; s &lt;= num_subsets; s++) {
        // Try each way of partitioning the leaves
        double c_s = INF_D;
        unsigned char p_s = 0;
        unsigned char d = (s - 1) &amp; s;
        unsigned char p = (-d) &amp; s;
        while (p != 0) {
          float c = c_opt[p] + c_opt[s ^ p];
          if (c &lt; c_s) {
              c_s = c;
              p_s = p;
          }

          p = (p - d) &amp; s;
        }
        // Calculate final SAH cost
        c_opt[s] = 1.2 * a[s] + c_s;
        p_opt[s] = p_s;
      }
    }
  }
}
</code></pre>

<ul>
<li>
<p>updateCost()</p>

<ul>
<li>Input: node from the BVH</li>
<li>Output: void</li>
</ul>
</li>
</ul>

<blockquote>
<p>for the node in the tree calculate the cost of each node according to it's children's cost</p>
</blockquote>

<pre><code>void updateCost(BVHNode *root, std::vector&lt;BVHNode *&gt;leaves, int num_leaves) {
    for (int i = 0; i &lt; num_leaves; i++) {
        BVHNode *cur = leaves[i];
        cur = cur-&gt;p;
        while (cur != root) {
            if (cur-&gt;cost == 0.0) {
                if (cur-&gt;left-&gt;cost != 0.0 &amp;&amp; cur-&gt;right-&gt;cost != 0.0) {
                    // Both left &amp; right propagated
                    BBox *bb_cur = &amp;cur-&gt;bound;
                    merge_bounds(cur-&gt;l-&gt;bb, cur-&gt;right-&gt;bb, bb_cur);
                    cur-&gt;cost = Ct * cur-&gt;bb-&gt;surface_area() + cur-&gt;left-&gt;cost + cur-&gt;right-&gt;cost;
                } else {
                    // Only one side propagated
                    break;
                }
            }
            cur = cur-&gt;p;
        }
    }

    // Cost of the root
    BBox *bbox = &amp;root-&gt;bb;
    merge_bounds(root-&gt;l-&gt;bb, root-&gt;r-&gt;bb, bbox);
    root-&gt;cost = Ct * root-&gt;bb-&gt;surface_area() + root-&gt;l-&gt;cost + root-&gt;r-&gt;cost;
}
</code></pre>

<ul>
<li>rebuildBVH()

<ul>
<li>Input: the leaves and nodes of the current node</li>
<li>Output: the rebuilt out structure of the current node</li>
</ul>
</li>
</ul>

<blockquote>
<p>rebuild the BVH structure of the current node</p>
</blockquote>

<pre><code>void rebuildBVH(std::vector&lt;BVHNode *&gt;leaves, std::vector&lt;BVHNode *&gt;nodes, int num_leaves, bool left, BVHNode *parent) {
    int i = leaves.length();
    while (i &gt; 0) {
      i--;
      BVHNode *leaf = leaves[i];
      if (left) {
        parent-&gt;l = leaf;
      } else {
        parent-&gt;r = leaf;
      }
        leaf-&gt;p = parent;
    }
    int j = nodes.length();
    while(j &gt; 0)
    {       
       BVHNode *node = nodes[];
       node-&gt;cost = 0.0;
       if (left) {
         parent-&gt;left = node;
       } else {
         parent-&gt;right = node;
       }
         node-&gt;parent = parent;    
    }
    updateCost(parent, leaves, num_leaves);
}
</code></pre>

<ul>
<li>treeletOptimize()

<ul>
<li>Input: current node</li>
<li>Output: void</li>
</ul>
</li>
</ul>

<blockquote>
<p>Optimize the treelet structure of the current node</p>
</blockquote>

<pre><code>void treeletOptimize(BVHNode *root) {
    if (root-&gt;isLeaf()) return;

    // Find a treelet with max number of leaves being 7
    std::vector&lt;BVHNode *&gt;leaves(7);
    int counter = 0;
    leaves[counter++] = root-&gt;l;
    leaves[counter++] = root-&gt;r;

    std::vector&lt;BVHNode *&gt;nodes(5);
    int nodes_counter = 0;

    double max_area;
    int max_index = 0;

    while (counter &lt; 7 &amp;&amp; max_index != -1) {
        max_index = -1;
        max_area = -1.0;

        for (int i = 0; i &lt; counter; i++) {
            if (!(leaves[i]-&gt;leaf)) {
                float area = leaves[i]-&gt;area;
                if (area &gt; max_area) {
                    max_area = area;
                    max_index = i;
                }
            }
        }

        if (max_index != -1) {

            BVHNode *tmp = leaves[max_index];

            // Put this node in nodes array
            nodes[nodes_counter++] = tmp;

            // Replace the max node with its children
            leaves[max_index] = leaves[counter - 1];
            leaves[counter - 1] = tmp-&gt;l;
            leaves[counter++] = tmp-&gt;r;
        }
    }

    unsigned char optimal[128];

    // Call calculateOptimalCost here
    optimizeTreelet(counter, leaves);

    // Use complement on right tree, and use original on left tree
    unsigned char mask = (1 &lt;&lt; counter) - 1;    // mask = max index
    int index = 0;                              // index for free nodes
    unsigned char leftIndex = mask;
    unsigned char left = optimal[leftIndex];
    rebuildBVH(leaves, nodes, left, counter, root);

    unsigned char right = (~left) &amp; mask;
    rebuildTree(leaves, nodes, right, counter, root);

    // Calculate current node's area &amp; cost
    BBox *bound = &amp;root-&gt;bb;
    mergeBox(root-&gt;l-&gt;bb, root-&gt;r-&gt;bb, bound);
    root-&gt;cost = Ci * root-&gt;bb-&gt;getArea() + root-&gt;l-&gt;cost + root-&gt;r-&gt;cost;
}
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/fishirenee/15662_asst5">Assignment 5: Improve performance of BVH construction</a> is maintained by <a href="https://github.com/fishirenee">fishirenee</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
